"""Provides helper functions for working with date and time data."""

from enum import StrEnum
from typing import Any
import datetime

import numpy as np
from numpy.typing import NDArray
from ataraxis_base_utilities import console, convert_bytes_to_scalar, convert_scalar_to_bytes

# The number of parts in a valid Date and Time (DT) string generated by this module.
_DT_STRING_PARTS = 7

# The maximum number of parts in a valid Date and Time (DT) string generated by this module.
_DT_MAX_PARTS = 7


class TimeUnits(StrEnum):
    """Defines the time units supported by the convert_time() function.

    Use this enumeration to specify the source and destination time units when calling the conversion function.
    """

    NANOSECOND = "ns"
    """Nanosecond time unit."""
    MICROSECOND = "us"
    """Microsecond time unit."""
    MILLISECOND = "ms"
    """Millisecond time unit."""
    SECOND = "s"
    """Second time unit."""
    MINUTE = "m"
    """Minute time unit."""
    HOUR = "h"
    """Hour time unit."""
    DAY = "d"
    """Day time unit."""


class TimestampFormats(StrEnum):
    """Defines the timestamp formats supported by the get_timestamp() and the convert_timestamp() functions.

    Use this enumeration when generating or converting timestamps.
    """

    STRING = "str"
    """A delimited date-and-time string. The timestamp is stored in the 'YYYY-MM-DD-HH-MM-SS-ssssss' format and uses
    UTC timezone."""
    BYTES = "byte"
    """A NumPy byte array. The timestamp is stored as a 64-bit unsigned integer serialized using little endian scheme
    that represents the number of microseconds elapsed since the UTC epoch onset."""
    INTEGER = "int"
    """The integer that represents the number of microseconds elapsed since the UTC epoch onset."""


class TimestampPrecisions(StrEnum):
    """Defines the precision levels supported by timestamp functions.

    Use this enumeration to control how much detail is included in generated or converted timestamps.
    """

    YEAR = "year"
    """Year precision (YYYY)."""
    MONTH = "month"
    """Month precision (YYYY-MM)."""
    DAY = "day"
    """Day precision (YYYY-MM-DD)."""
    HOUR = "hour"
    """Hour precision (YYYY-MM-DD-HH)."""
    MINUTE = "minute"
    """Minute precision (YYYY-MM-DD-HH-MM)."""
    SECOND = "second"
    """Second precision (YYYY-MM-DD-HH-MM-SS)."""
    MICROSECOND = "microsecond"
    """Microsecond precision (YYYY-MM-DD-HH-MM-SS-ssssss). This is the default and preserves full detail."""


# Maps each TimestampPrecisions level to the number of string parts to include in the output.
_PRECISION_PARTS: dict[str, int] = {
    "year": 1,
    "month": 2,
    "day": 3,
    "hour": 4,
    "minute": 5,
    "second": 6,
    "microsecond": 7,
}


def _truncate_microseconds(microseconds: int, precision: str) -> int:
    """Floors a microsecond-since-epoch value to the given precision boundary.

    This zeros out all sub-precision fields by reconstructing a datetime with only the fields up to the requested
    precision level, then converting back to microseconds.

    Args:
        microseconds: The microsecond timestamp to truncate.
        precision: The precision level to truncate to. Must be a valid TimestampPrecisions value.

    Returns:
        The truncated microsecond timestamp.
    """
    if precision == TimestampPrecisions.MICROSECOND:
        return microseconds

    # Reconstructs the datetime from microseconds.
    seconds = float(microseconds) // 1_000_000
    microseconds_part = int(microseconds % 1_000_000)
    dt = datetime.datetime.fromtimestamp(seconds, tz=datetime.UTC).replace(microsecond=microseconds_part)

    # Zeroes out sub-precision fields by constructing a new datetime with only the fields up to the precision level.
    dt = datetime.datetime(
        year=dt.year,
        month=dt.month if precision != "year" else 1,
        day=dt.day if precision not in ("year", "month") else 1,
        hour=dt.hour if precision not in ("year", "month", "day") else 0,
        minute=dt.minute if precision not in ("year", "month", "day", "hour") else 0,
        second=dt.second if precision not in ("year", "month", "day", "hour", "minute") else 0,
        microsecond=dt.microsecond if precision not in ("year", "month", "day", "hour", "minute", "second") else 0,
        tzinfo=datetime.UTC,
    )
    return int(dt.timestamp() * 1_000_000)


def convert_time(
    time: float | np.integer[Any] | np.floating[Any],
    from_units: str | TimeUnits,
    to_units: str | TimeUnits,
    *,
    as_float: bool = False,
) -> float | np.float64:
    """Converts the input time value from the original units to the requested units.

    Notes:
        By default, this function returns the converted time value as a NumPy 64-bit floating scalar.

        The conversion uses 3 decimal places rounding.

    Args:
        time: The time-value to convert.
        from_units: The units used by the input data. Use one of the valid options defined in the TimeUnits enumeration:
            'ns' (nanoseconds), 'us' (microseconds), 'ms' (milliseconds), 's' (seconds), 'm' (minutes), 'h' (hours),
            'd' (days).
        to_units: The units to convert the input data to. Uses the same options as the 'from_units' argument.
        as_float: Determines whether to return the converted time as a Python floating object (if True) or a NumPy
            64-bit floating scalar type (if False).

    Returns:
        The converted time-value given in the requested time-units. Depending on the 'as_float' argument, the value is
        returned either as a Python float or a NumPy 64-bit floating scalar.

    Raises:
        ValueError: If 'from_units' or 'to_units' argument is not set to a valid time-option.
    """
    conversion_dict: dict[str, int | float] = {
        "d": 86400,  # seconds in a day
        "h": 3600,  # seconds in an hour
        "m": 60,  # seconds in a minute
        "s": 1,  # seconds in a second
        "ms": 0.001,  # seconds in a millisecond
        "us": 1e-6,  # seconds in a microsecond
        "ns": 1e-9,  # seconds in a nanosecond
    }

    # Validates that the unit options are valid.
    if from_units not in conversion_dict:
        message = (
            f"Unable to convert time value. The 'from_units' must be one of the valid members defined in the "
            f"TimeUnits enumeration ({', '.join(tuple(TimeUnits))}), but got {from_units}."
        )
        console.error(message=message, error=ValueError)

    if to_units not in conversion_dict:
        message = (
            f"Unable to convert time value. The 'to_units' must be one of the valid members defined in the "
            f"TimeUnits enumeration ({', '.join(tuple(TimeUnits))}), but got {to_units}."
        )
        console.error(message=message, error=ValueError)

    # Converts the input value to a NumPy 64-bit floating point value. This prepares the data for processing and acts
    # as a check for whether the input value is NumPy-float-convertible (valid).
    time = np.float64(time)

    # Converts the time to the desired time format and rounds the resultant value to 3 decimal places.
    converted_time = np.round(
        (time * conversion_dict[from_units]) / conversion_dict[to_units],
        decimals=3,
    )

    # If requested, returns the converted value as a Python float. Otherwise, returns it as a NumPy 64-bit floating
    # scalar.
    if as_float:
        return float(converted_time)
    return converted_time


def get_timestamp(
    output_format: str | TimestampFormats = TimestampFormats.STRING,
    time_separator: str = "-",
    precision: str | TimestampPrecisions = TimestampPrecisions.MICROSECOND,
) -> str | int | NDArray[np.uint8]:
    """Gets the current Coordinated Universal Time (UTC) timestamp (date and time) and returns it using the requested
    output format.

    Notes:
        The bytes'-converted timestamp is encoded using the little-endian format.

    Args:
        output_format: The format in which to return the timestamp. Use one of the valid options defined in the
            TimestampFormats enumeration: "str", "byte", or "int".
        time_separator: The separator to use for delimiting the date-and-time string. This is only used if the
            'output_format' argument is set to "str".
        precision: The precision level for the output timestamp. Use one of the valid options defined in the
            TimestampPrecisions enumeration. For STRING format, this controls how many date/time components are
            included. For INTEGER and BYTES formats, sub-precision fields are zeroed out.

    Returns:
        The current UTC timestamp converted to the requested output format.

    Raises:
        TypeError: If the 'time_separator' argument is not a string.
        ValueError: If the 'output_format' argument is not set to a valid format option, or if the 'precision'
            argument is not a valid TimestampPrecisions value.
    """
    # Validates the precision argument.
    if precision not in tuple(TimestampPrecisions):
        message = (
            f"Unable to get UTC timestamp. The 'precision' must be one of the valid members defined in the "
            f"TimestampPrecisions enumeration ({', '.join(tuple(TimestampPrecisions))}), but got {precision}."
        )
        console.error(message=message, error=ValueError)

    # Gets the atomic time using a timezone-aware query.
    now = datetime.datetime.now(datetime.UTC)

    # Converts UTC timestamp to microseconds elapsed since UTC epoch onset.
    microseconds = int(now.timestamp() * 1_000_000)

    # Applies precision truncation for non-string formats.
    truncated_microseconds = _truncate_microseconds(microseconds, precision)

    # Integer format.
    if output_format == TimestampFormats.INTEGER:
        return truncated_microseconds

    # NumPy bytes array format.
    if output_format == TimestampFormats.BYTES:
        return convert_scalar_to_bytes(value=truncated_microseconds)

    # String format.
    if output_format == TimestampFormats.STRING:
        # Validates that the time separator is a string.
        if not isinstance(time_separator, str):
            message = (
                f"Unable to get UTC timestamp. The 'time_separator' must be a string, but got "
                f"{time_separator} of type {type(time_separator).__name__}."
            )
            console.error(message=message, error=TypeError)

        # Formats the timestamp into a string using the requested delimiter.
        full_string = now.strftime(
            f"%Y{time_separator}%m{time_separator}%d{time_separator}%H{time_separator}%M{time_separator}"
            f"%S{time_separator}%f"
        )

        # Truncates the string based on precision level.
        num_parts = _PRECISION_PARTS[precision]
        if num_parts < _DT_MAX_PARTS:
            parts = full_string.split(time_separator)
            return time_separator.join(parts[:num_parts])
        return full_string

    # Unsupported output format.
    message = (
        f"Unable to get UTC timestamp. The 'output_format' must be one of the valid members defined in the "
        f"TimestampFormats enumeration ({', '.join(tuple(TimestampFormats))}), but got {output_format}."
    )
    console.error(message=message, error=ValueError)
    # noinspection PyUnreachableCode
    raise ValueError(message)  # pragma: no cover


def convert_timestamp(
    timestamp: str | int | NDArray[np.uint8],
    time_separator: str = "-",
    output_format: str | TimestampFormats = TimestampFormats.STRING,
    precision: str | TimestampPrecisions = TimestampPrecisions.MICROSECOND,
) -> str | int | NDArray[np.uint8]:
    """Converts a timestamp generated by the get_timestamp() function into a different format.

    Notes:
        This method is primarily designed to decode byte-serialized timestamps produced by the get_timestamp() function
        into other formats. String inputs may have 1 to 7 delimited parts; missing fields are filled with defaults
        (month=1, day=1, hour=0, minute=0, second=0, microsecond=0).

    Args:
        timestamp: The timestamp value to convert.
        time_separator: The separator to use for delimiting the date-and-time string. This is used when parsing input
            date-and-time strings and when converting timestamps to the string format.
        output_format: The format in which to return the timestamp. Use one of the valid options defined in the
            TimestampFormats enumeration: "str", "byte", or "int".
        precision: The precision level for the output timestamp. Use one of the valid options defined in the
            TimestampPrecisions enumeration. For STRING format, this controls how many date/time components are
            included. For INTEGER and BYTES formats, sub-precision fields are zeroed out.

    Returns:
        The timestamp converted to the requested format.

    Raises:
        TypeError: If the 'time_separator' argument is not a string, or if the 'timestamp' argument is not of a valid
            type.
        ValueError: If the 'output_format' argument is not set to a valid format option, or if the 'precision'
            argument is not a valid TimestampPrecisions value.
    """
    # Validates that the time separator is a string.
    if not isinstance(time_separator, str):
        message = (
            f"Unable to convert timestamp. The 'time_separator' must be a string, but got "
            f"{time_separator} of type {type(time_separator).__name__}."
        )
        console.error(message=message, error=TypeError)

    # Validates the precision argument.
    if precision not in tuple(TimestampPrecisions):
        message = (
            f"Unable to convert timestamp. The 'precision' must be one of the valid members defined in the "
            f"TimestampPrecisions enumeration ({', '.join(tuple(TimestampPrecisions))}), but got {precision}."
        )
        console.error(message=message, error=ValueError)

    # Converts the input to microseconds based on the input type.
    microseconds: int = 0  # Pre-initializes the variable to appease mypy.
    if isinstance(timestamp, np.ndarray):
        # Validates that the timestamp is stored as a one-dimensional uint8 array.
        if timestamp.dtype != np.uint8 or timestamp.ndim != 1:
            message = (
                f"Unable to convert bytes timestamp. The 'timestamp' must be a one-dimensional uint8 numpy array, "
                f"but got {timestamp} of type {type(timestamp).__name__} with dtype {timestamp.dtype} and shape "
                f"{timestamp.shape}."
            )
            console.error(message=message, error=TypeError)

        # Converts the bytes array to elapsed microseconds since UTC epoch onset.
        microseconds = int(convert_bytes_to_scalar(data=timestamp))

    # Integer input
    elif isinstance(timestamp, int):
        microseconds = timestamp

    # String input
    elif isinstance(timestamp, str):
        # Parses the string timestamp using the provided separator.
        try:
            # Expected format: YYYY-MM-DD-HH-MM-SS-ffffff (with custom separator), but accepts 1-7 parts.
            parts = timestamp.split(time_separator)
            num_parts = len(parts)
            if num_parts < 1 or num_parts > _DT_MAX_PARTS:
                message = (
                    f"Unable to convert string timestamp. The timestamp must have 1 to 7 delimited parts, but got "
                    f"'{timestamp}' with {num_parts} parts."
                )
                raise ValueError(message)

            # Default values for missing fields: year=0, month=1, day=1, rest=0.
            defaults = [0, 1, 1, 0, 0, 0, 0]

            # Parses provided components, fills missing ones with defaults.
            values = [int(parts[i]) if i < num_parts else defaults[i] for i in range(_DT_MAX_PARTS)]
            year, month, day, hour, minute, second, microsecond = values

            # Creates a datetime object.
            dt = datetime.datetime(year, month, day, hour, minute, second, microsecond, tzinfo=datetime.UTC)

            # Converts to microseconds since UTC epoch onset.
            microseconds = int(dt.timestamp() * 1_000_000)

        except (ValueError, IndexError):
            message = (
                f"Unable to convert string timestamp. The timestamp must follow the format "
                f"YYYY{time_separator}MM{time_separator}DD{time_separator}HH{time_separator}MM"
                f"{time_separator}SS{time_separator}ffffff (1 to 7 parts), but got '{timestamp}'."
            )
            console.error(message=message, error=ValueError)

    else:
        message = (
            f"Unable to convert timestamp. The 'timestamp' must be a string, integer, or NumPy array, but got "
            f"{timestamp} of type {type(timestamp).__name__}."
        )
        console.error(message=message, error=TypeError)

    # Applies precision truncation.
    microseconds = _truncate_microseconds(microseconds, precision)

    # Converts microseconds to the requested output format.
    # Integer format.
    if output_format == TimestampFormats.INTEGER:
        return microseconds

    # NumPy bytes array format.
    if output_format == TimestampFormats.BYTES:
        return convert_scalar_to_bytes(value=microseconds)

    # String format.
    if output_format == TimestampFormats.STRING:
        # Splits into seconds and microseconds components.
        seconds = float(microseconds) // 1_000_000
        microseconds_part = int(microseconds % 1_000_000)

        # Creates a UTC datetime with microsecond precision.
        timestamp_dt = datetime.datetime.fromtimestamp(seconds, tz=datetime.UTC).replace(microsecond=microseconds_part)

        # Formats with the specified separator.
        full_string = timestamp_dt.strftime(
            f"%Y{time_separator}%m{time_separator}%d{time_separator}%H{time_separator}%M{time_separator}"
            f"%S{time_separator}%f"
        )

        # Truncates the string based on precision level.
        num_parts = _PRECISION_PARTS[precision]
        if num_parts < _DT_MAX_PARTS:
            output_parts = full_string.split(time_separator)
            return time_separator.join(output_parts[:num_parts])
        return full_string

    # Unsupported output format.
    message = (
        f"Unable to convert timestamp. The 'output_format' must be one of the valid members defined in the "
        f"TimestampFormats enumeration ({', '.join(tuple(TimestampFormats))}), but got {output_format}."
    )
    console.error(message=message, error=ValueError)
    # noinspection PyUnreachableCode
    raise ValueError(message)  # pragma: no cover


def parse_timestamp(
    date_string: str,
    format_string: str,
    *,
    output_format: str | TimestampFormats = TimestampFormats.INTEGER,
    time_separator: str = "-",
    precision: str | TimestampPrecisions = TimestampPrecisions.MICROSECOND,
) -> str | int | NDArray[np.uint8]:
    """Parses an arbitrary datetime string and returns it as a timestamp in the requested format.

    Notes:
        The input datetime string is parsed using datetime.strptime() with the provided format string. The parsed
        datetime is assumed to be in UTC timezone. The output respects the same format and precision options as
        get_timestamp() and convert_timestamp().

    Args:
        date_string: The datetime string to parse.
        format_string: The strptime-compatible format string used to parse the date_string.
        output_format: The format in which to return the timestamp. Use one of the valid options defined in the
            TimestampFormats enumeration: "str", "byte", or "int".
        time_separator: The separator to use for delimiting the date-and-time string. This is only used if the
            'output_format' argument is set to "str".
        precision: The precision level for the output timestamp. Use one of the valid options defined in the
            TimestampPrecisions enumeration.

    Returns:
        The parsed timestamp in the requested output format.

    Raises:
        ValueError: If the date_string cannot be parsed with the provided format_string, if the output_format is
            invalid, or if the precision is invalid.
    """
    # Validates the precision argument.
    if precision not in tuple(TimestampPrecisions):
        message = (
            f"Unable to parse timestamp. The 'precision' must be one of the valid members defined in the "
            f"TimestampPrecisions enumeration ({', '.join(tuple(TimestampPrecisions))}), but got {precision}."
        )
        console.error(message=message, error=ValueError)

    # Parses the date string using the provided format.
    try:
        dt = datetime.datetime.strptime(date_string, format_string).replace(tzinfo=datetime.UTC)
    except ValueError:
        message = (
            f"Unable to parse timestamp. The date string '{date_string}' could not be parsed with the format "
            f"string '{format_string}'."
        )
        console.error(message=message, error=ValueError)

    # Converts the parsed datetime to microseconds since UTC epoch onset.
    microseconds = int(dt.timestamp() * 1_000_000)

    # Applies precision truncation.
    microseconds = _truncate_microseconds(microseconds, precision)

    # Uses the same output logic as get_timestamp/convert_timestamp.
    if output_format == TimestampFormats.INTEGER:
        return microseconds

    if output_format == TimestampFormats.BYTES:
        return convert_scalar_to_bytes(value=microseconds)

    if output_format == TimestampFormats.STRING:
        # Reconstructs datetime from truncated microseconds.
        seconds = float(microseconds) // 1_000_000
        microseconds_part = int(microseconds % 1_000_000)
        timestamp_dt = datetime.datetime.fromtimestamp(seconds, tz=datetime.UTC).replace(microsecond=microseconds_part)

        full_string = timestamp_dt.strftime(
            f"%Y{time_separator}%m{time_separator}%d{time_separator}%H{time_separator}%M{time_separator}"
            f"%S{time_separator}%f"
        )

        num_parts = _PRECISION_PARTS[precision]
        if num_parts < _DT_MAX_PARTS:
            parts = full_string.split(time_separator)
            return time_separator.join(parts[:num_parts])
        return full_string

    message = (
        f"Unable to parse timestamp. The 'output_format' must be one of the valid members defined in the "
        f"TimestampFormats enumeration ({', '.join(tuple(TimestampFormats))}), but got {output_format}."
    )
    console.error(message=message, error=ValueError)
    # noinspection PyUnreachableCode
    raise ValueError(message)  # pragma: no cover


def rate_to_interval(
    rate: float | np.integer[Any] | np.floating[Any],
    to_units: str | TimeUnits = TimeUnits.MICROSECOND,
    *,
    as_float: bool = False,
) -> float | np.float64:
    """Converts a frequency in Hz to a time interval in the requested units.

    Args:
        rate: The frequency in Hz to convert. Must be greater than 0.
        to_units: The time units for the output interval. Use one of the valid options defined in the TimeUnits
            enumeration.
        as_float: Determines whether to return the result as a Python float (if True) or a NumPy 64-bit floating
            scalar (if False).

    Returns:
        The time interval corresponding to the given frequency, in the requested units.

    Raises:
        ValueError: If the rate is not greater than 0, or if to_units is not a valid time unit.
    """
    rate_value = float(rate)
    if rate_value <= 0:
        message = f"Unable to convert rate to interval. The 'rate' must be greater than 0, but got {rate}."
        console.error(message=message, error=ValueError)

    return convert_time(1.0 / rate_value, from_units="s", to_units=to_units, as_float=as_float)


def interval_to_rate(
    interval: float | np.integer[Any] | np.floating[Any],
    from_units: str | TimeUnits = TimeUnits.MICROSECOND,
    *,
    as_float: bool = False,
) -> float | np.float64:
    """Converts a time interval to a frequency in Hz.

    Args:
        interval: The time interval to convert. Must be greater than 0.
        from_units: The time units of the input interval. Use one of the valid options defined in the TimeUnits
            enumeration.
        as_float: Determines whether to return the result as a Python float (if True) or a NumPy 64-bit floating
            scalar (if False).

    Returns:
        The frequency in Hz corresponding to the given time interval.

    Raises:
        ValueError: If the interval is not greater than 0, or if from_units is not a valid time unit.
    """
    interval_value = float(interval)
    if interval_value <= 0:
        message = f"Unable to convert interval to rate. The 'interval' must be greater than 0, but got {interval}."
        console.error(message=message, error=ValueError)

    seconds = convert_time(interval_value, from_units=from_units, to_units="s", as_float=True)
    # Casts to float since convert_time with as_float=True returns float.
    result = 1.0 / float(seconds)
    if as_float:
        return result
    return np.float64(result)


def to_timedelta(
    time: float | np.integer[Any] | np.floating[Any],
    from_units: str | TimeUnits,
) -> datetime.timedelta:
    """Converts a time value in the given units to a datetime.timedelta.

    Args:
        time: The time value to convert.
        from_units: The units of the input time value. Use one of the valid options defined in the TimeUnits
            enumeration.

    Returns:
        A datetime.timedelta representing the given time value.

    Raises:
        ValueError: If from_units is not a valid time unit.
    """
    seconds = convert_time(time, from_units=from_units, to_units="s", as_float=True)
    return datetime.timedelta(seconds=float(seconds))


def from_timedelta(
    timedelta_value: datetime.timedelta,
    to_units: str | TimeUnits,
    *,
    as_float: bool = False,
) -> float | np.float64:
    """Converts a datetime.timedelta to a numeric value in the requested units.

    Args:
        timedelta_value: The timedelta to convert.
        to_units: The units for the output value. Use one of the valid options defined in the TimeUnits enumeration.
        as_float: Determines whether to return the result as a Python float (if True) or a NumPy 64-bit floating
            scalar (if False).

    Returns:
        The numeric value of the timedelta in the requested units.

    Raises:
        ValueError: If to_units is not a valid time unit.
    """
    return convert_time(timedelta_value.total_seconds(), from_units="s", to_units=to_units, as_float=as_float)
