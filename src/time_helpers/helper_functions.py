"""Provides helper functions for working with date and time data."""

from enum import StrEnum
from typing import Any
import datetime

import numpy as np
from numpy.typing import NDArray
from ataraxis_base_utilities import console, convert_bytes_to_scalar, convert_scalar_to_bytes

# The number of parts in a valid Date and Time (DT) string generated by this module.
_DT_STRING_PARTS = 7


class TimeUnits(StrEnum):
    """Defines the time units supported by the convert_time() function.

    Use this enumeration to specify the source and destination time units when calling the conversion function.
    """

    NANOSECOND = "ns"
    """Nanosecond time unit."""
    MICROSECOND = "us"
    """Microsecond time unit."""
    MILLISECOND = "ms"
    """Millisecond time unit."""
    SECOND = "s"
    """Second time unit."""
    MINUTE = "m"
    """Minute time unit."""
    HOUR = "h"
    """Hour time unit."""
    DAY = "d"
    """Day time unit."""


class TimestampFormats(StrEnum):
    """Defines the timestamp formats supported by the get_timestamp() and the convert_timestamp() functions.

    Use this enumeration when generating or converting timestamps.
    """

    STRING = "str"
    """A delimited date-and-time string. The timestamp is stored in the 'YYYY-MM-DD-HH-MM-SS-ssssss' format and uses
    UTC timezone."""
    BYTES = "byte"
    """A NumPy byte array. The timestamp is stored as a 64-bit unsigned integer serialized using little endian scheme
    that represents the number of microseconds elapsed since the UTC epoch onset."""
    INTEGER = "int"
    """The integer that represents the number of microseconds elapsed since the UTC epoch onset."""


def convert_time(
    time: float | np.integer[Any] | np.floating[Any],
    from_units: str | TimeUnits,
    to_units: str | TimeUnits,
    *,
    as_float: bool = False,
) -> float | np.float64:
    """Converts the input time value from the original units to the requested units.

    Notes:
        By default, this function returns the converted time value as a NumPy 64-bit floating scalar.

        The conversion uses 3 decimal places rounding.

    Args:
        time: The time-value to convert.
        from_units: The units used by the input data. Use one of the valid options defined in the TimeUnits enumeration:
            'ns' (nanoseconds), 'us' (microseconds), 'ms' (milliseconds), 's' (seconds), 'm' (minutes), 'h' (hours),
            'd' (days).
        to_units: The units to convert the input data to. Uses the same options as the 'from_units' argument.
        as_float: Determines whether to return the converted time as a Python floating object (if True) or a NumPy
            64-bit floating scalar type (if False).

    Returns:
        The converted time-value given in the requested time-units. Depending on the 'as_float' argument, the value is
        returned either as a Python float or a NumPy 64-bit floating scalar.

    Raises:
        ValueError: If 'from_units' or 'to_units' argument is not set to a valid time-option.
    """
    conversion_dict: dict[str, int | float] = {
        "d": 86400,  # seconds in a day
        "h": 3600,  # seconds in an hour
        "m": 60,  # seconds in a minute
        "s": 1,  # seconds in a second
        "ms": 0.001,  # seconds in a millisecond
        "us": 1e-6,  # seconds in a microsecond
        "ns": 1e-9,  # seconds in a nanosecond
    }

    # Validates that the unit options are valid.
    if from_units not in conversion_dict:
        message = (
            f"Unable to convert time value. The 'from_units' must be one of the valid members defined in the "
            f"TimeUnits enumeration ({', '.join(tuple(TimeUnits))}), but got {from_units}."
        )
        console.error(message=message, error=ValueError)

    if to_units not in conversion_dict:
        message = (
            f"Unable to convert time value. The 'to_units' must be one of the valid members defined in the "
            f"TimeUnits enumeration ({', '.join(tuple(TimeUnits))}), but got {to_units}."
        )
        console.error(message=message, error=ValueError)

    # Converts the input value to a NumPy 64-bit floating point value. This prepares the data for processing and acts
    # as a check for whether the input value is NumPy-float-convertible (valid).
    time = np.float64(time)

    # Converts the time to the desired time format and rounds the resultant value to 3 decimal places.
    converted_time = np.round(
        (time * conversion_dict[from_units]) / conversion_dict[to_units],
        decimals=3,
    )

    # If requested, returns the converted value as a Python float. Otherwise, returns it as a NumPy 64-bit floating
    # scalar.
    if as_float:
        return float(converted_time)
    return converted_time


def get_timestamp(
    output_format: str | TimestampFormats = TimestampFormats.STRING, time_separator: str = "-"
) -> str | int | NDArray[np.uint8]:
    """Gets the current Coordinated Universal Time (UTC) timestamp (date and time) and returns it using the requested
    output format.

    Notes:
        The bytes'-converted timestamp is encoded using the little-endian format.

    Args:
        output_format: The format in which to return the timestamp. Use one of the valid options defined in the
            TimestampFormats enumeration: "str", "byte", or "int".
        time_separator: The separator to use for delimiting the date-and-time string. This is only used if the
            'output_format' argument is set to "str".

    Returns:
        The current UTC timestamp converted to the requested output format.

    Raises:
        TypeError: If the 'time_separator' argument is not a string.
        ValueError: If the 'output_format' argument is not set to a valid format option.
    """
    # Gets the atomic time using a timezone-aware query.
    now = datetime.datetime.now(datetime.UTC)

    # Converts UTC timestamp to microseconds elapsed since UTC epoch onset.
    microseconds = int(now.timestamp() * 1_000_000)

    # Integer format.
    if output_format == TimestampFormats.INTEGER:
        return microseconds

    # NumPy bytes array format.
    if output_format == TimestampFormats.BYTES:
        return convert_scalar_to_bytes(value=microseconds)

    # String format.
    if output_format == TimestampFormats.STRING:
        # Validates that the time separator is a string.
        if not isinstance(time_separator, str):
            message = (
                f"Unable to get UTC timestamp. The 'time_separator' must be a string, but got "
                f"{time_separator} of type {type(time_separator).__name__}."
            )
            console.error(message=message, error=TypeError)

        # Formats the timestamp into a string using the requested delimiter and returns it to the caller.
        return now.strftime(
            f"%Y{time_separator}%m{time_separator}%d{time_separator}%H{time_separator}%M{time_separator}"
            f"%S{time_separator}%f"
        )
    # Unsupported output format.
    message = (
        f"Unable to get UTC timestamp. The 'output_format' must be one of the valid members defined in the "
        f"TimestampFormats enumeration ({', '.join(tuple(TimestampFormats))}), but got {output_format}."
    )
    console.error(message=message, error=ValueError)
    # noinspection PyUnreachableCode
    raise ValueError(message)  # pragma: no cover


def convert_timestamp(
    timestamp: str | int | NDArray[np.uint8],
    time_separator: str = "-",
    output_format: str | TimestampFormats = TimestampFormats.STRING,
) -> str | int | NDArray[np.uint8]:
    """Converts a timestamp generated by the get_timestamp() function into a different format.

    Notes:
        This method is primarily designed to decode byte-serialized timestamps produced by the get_timestamp() function
        into other formats.

    Args:
        timestamp: The timestamp value to convert.
        time_separator: The separator to use for delimiting the date-and-time string. This is used when parsing input
            date-and-time strings and when converting timestamps to the string format.
        output_format: The format in which to return the timestamp. Use one of the valid options defined in the
            TimestampFormats enumeration: "str", "byte", or "int".

    Returns:
        The timestamp converted to the requested format.

    Raises:
        TypeError: If the 'time_separator' argument is not a string, or if the 'timestamp' argument is not of a valid
            type.
        ValueError: If the 'output_format' argument is not set to a valid format option.
    """
    # Validates that the time separator is a string.
    if not isinstance(time_separator, str):
        message = (
            f"Unable to convert timestamp. The 'time_separator' must be a string, but got "
            f"{time_separator} of type {type(time_separator).__name__}."
        )
        console.error(message=message, error=TypeError)

    # Converts the input to microseconds based on the input type.
    microseconds: int = 0  # Pre-initializes the variable to appease mypy.
    if isinstance(timestamp, np.ndarray):
        # Validates that the timestamp is stored as a one-dimensional uint8 array.
        if timestamp.dtype != np.uint8 or timestamp.ndim != 1:
            message = (
                f"Unable to convert bytes timestamp. The 'timestamp' must be a one-dimensional uint8 numpy array, "
                f"but got {timestamp} of type {type(timestamp).__name__} with dtype {timestamp.dtype} and shape "
                f"{timestamp.shape}."
            )
            console.error(message=message, error=TypeError)

        # Converts the bytes array to elapsed microseconds since UTC epoch onset.
        microseconds = int(convert_bytes_to_scalar(data=timestamp))

    # Integer input
    elif isinstance(timestamp, int):
        microseconds = timestamp

    # String input
    elif isinstance(timestamp, str):
        # Parses the string timestamp using the provided separator.
        try:
            # Expected format: YYYY-MM-DD-HH-MM-SS-ffffff (with custom separator)
            parts = timestamp.split(time_separator)
            if len(parts) != _DT_STRING_PARTS:
                message = (
                    f"Unable to convert string timestamp. The timestamp must have 7 delimited parts, but got "
                    f"'{timestamp}' with {len(parts)} parts."
                )
                raise ValueError(message)

            # Parses each component.
            year = int(parts[0])
            month = int(parts[1])
            day = int(parts[2])
            hour = int(parts[3])
            minute = int(parts[4])
            second = int(parts[5])
            microsecond = int(parts[6])

            # Creates a datetime object.
            dt = datetime.datetime(year, month, day, hour, minute, second, microsecond, tzinfo=datetime.UTC)

            # Converts to microseconds since UTC epoch onset.
            microseconds = int(dt.timestamp() * 1_000_000)

        except (ValueError, IndexError):
            message = (
                f"Unable to convert string timestamp. The timestamp must follow the format "
                f"YYYY{time_separator}MM{time_separator}DD{time_separator}HH{time_separator}MM"
                f"{time_separator}SS{time_separator}ffffff, but got '{timestamp}'."
            )
            console.error(message=message, error=ValueError)

    else:
        message = (
            f"Unable to convert timestamp. The 'timestamp' must be a string, integer, or NumPy array, but got "
            f"{timestamp} of type {type(timestamp).__name__}."
        )
        console.error(message=message, error=TypeError)

    # Converts microseconds to the requested output format.
    # Integer format.
    if output_format == TimestampFormats.INTEGER:
        return microseconds

    # NumPy bytes array format.
    if output_format == TimestampFormats.BYTES:
        return convert_scalar_to_bytes(value=microseconds)

    # String format.
    if output_format == TimestampFormats.STRING:
        # Splits into seconds and microseconds components.
        seconds = float(microseconds) // 1_000_000
        microseconds_part = int(microseconds % 1_000_000)

        # Creates a UTC datetime with microsecond precision.
        timestamp_dt = datetime.datetime.fromtimestamp(seconds, tz=datetime.UTC).replace(microsecond=microseconds_part)

        # Formats with the specified separator and returns to the caller.
        return timestamp_dt.strftime(
            f"%Y{time_separator}%m{time_separator}%d{time_separator}%H{time_separator}%M{time_separator}"
            f"%S{time_separator}%f"
        )

    # Unsupported output format.
    message = (
        f"Unable to convert timestamp. The 'output_format' must be one of the valid members defined in the "
        f"TimestampFormats enumeration ({', '.join(tuple(TimestampFormats))}), but got {output_format}."
    )
    console.error(message=message, error=ValueError)
    # noinspection PyUnreachableCode
    raise ValueError(message)  # pragma: no cover
